var documenterSearchIndex = {"docs":
[{"location":"tutorials/model_comparison/#Model-comparison","page":"Model comparison","title":"Model comparison","text":"","category":"section"},{"location":"tutorials/model_comparison/#Comparing-parameters-of-a-single-generative-processes","page":"Model comparison","title":"Comparing parameters of a single generative processes","text":"","category":"section"},{"location":"tutorials/model_comparison/#Posterior-model-probability","page":"Model comparison","title":"Posterior model probability","text":"","category":"section"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"using ADDM\nusing CSV\nusing DataFrames\nusing DataFramesMeta\nusing StatsPlots","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Read in data from Krajbich et al. (2010)","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"krajbich_data = ADDM.load_data_from_csv(\"../../../data/Krajbich2010_behavior.csv\", \"../../../data/Krajbich2010_fixations.csv\")","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Run grid search for a single subject. This computes the nll for 64 parameter combinations for a single subject.","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"# fn = \"./data/Krajbich_grid.csv\"\nfn = \"../../../data/Krajbich_grid3.csv\"\ntmp = DataFrame(CSV.File(fn, delim=\",\"))\nparam_grid = Dict(pairs(NamedTuple.(eachrow(tmp))))\n\nmy_likelihood_args = (timeStep = 10.0, approxStateStep = 0.01)\n\nsubj_data = krajbich_data[\"18\"]\n  \nbest_pars, nll_df, model_posteriors = ADDM.grid_search(subj_data, ADDM.aDDM_get_trial_likelihood, param_grid, \n    Dict(:η=>0.0, :barrier=>1, :decay=>0, :nonDecisionTime=>0, :bias=>0.0), \n    likelihood_args=my_likelihood_args, \n    return_model_posteriors = true)\n","category":"page"},{"location":"tutorials/model_comparison/#Individual-parameter-posteriors","page":"Model comparison","title":"Individual parameter posteriors","text":"","category":"section"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Merge model posteriors with the model parameters they refer to. This creates a dataframe instead of the model_posteriors dictionary that is easier to make plots with.","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"posteriors_df = DataFrame()\n\nfor (k, v) in param_grid\n  cur_row = DataFrame([v])\n  cur_row.posterior = [model_posteriors[k]]\n  append!(posteriors_df, cur_row)\nend","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Plot model posteriors. Note the use of @chain and other operations such as @rsubset etc. for dplyr like functionality in Julia through DataFrameMeta.jl.  ","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Note also that we're only plotting the posteriors for models that have a meaningful amount of probability mass instead of all the 64 models that were tested.","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"plot_df = @chain posteriors_df begin\n  @rsubset :posterior > 1e-10\n  @rtransform :x_label = \"d: \" * string(:d) * \", \\nσ: \" * string(:sigma) * \", \\nθ: \" * string(:theta) \n  @orderby -:posterior\n  end\n\n@df plot_df bar(:x_label, :posterior, legend = false, xrotation = 45, ylabel = \"p(model|data)\",bottom_margin = (5, :mm))\n\nsavefig(\"plot3.png\"); nothing # hide","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"(Image: plot)","category":"page"},{"location":"tutorials/model_comparison/#Marginal-posteriors-for-parameters","page":"Model comparison","title":"Marginal posteriors for parameters","text":"","category":"section"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Compute and plot posteriors for each parameter","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"param_posteriors = ADDM.marginal_posteriors(param_grid, model_posteriors)\n\nplot_array = Any[]\nfor plot_df in param_posteriors\n  x_lab = names(plot_df)[1]\n  cur_plot = @df plot_df bar(plot_df[:, x_lab], :posterior_sum, leg = false, ylabel = \"p(\" * x_lab * \" = x|data)\", xlabel = x_lab )\n  push!(plot_array, cur_plot) \nend\nplot(plot_array...)\n\nsavefig(\"plot4.png\"); nothing # hide","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"(Image: plot)","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Compute and plot marginal posteriors with heatmaps","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"marginal_posteriors = ADDM.marginal_posteriors(param_grid, model_posteriors, true)\n\nADDM.margpostplot(marginal_posteriors)\n\nsavefig(\"plot5.png\"); nothing # hide","category":"page"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"(Image: plot)","category":"page"},{"location":"tutorials/model_comparison/#Comparing-different-generative-processes","page":"Model comparison","title":"Comparing different generative processes","text":"","category":"section"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"Estimate best fitting parameters separately for each process  \nIs this necessary? Do uou only need trial likelihoods and priors for each model (that are indexed in a way that leaves no ambiguity about which model generated with trial likelihoods)\nYou can't compute marginal parameter distributions across different generative processes (I don't think) but you could compare the two best fitting parameter combinations from one generative process to an entirely different generative process, as long as you have the trial likelihoods for each model.  \nCompute trial likelihoods plugging in best fitting parameters  \nCompute model posterior using trial likelihoods  \nDoes this violate any assumptions?","category":"page"},{"location":"tutorials/model_comparison/#More?","page":"Model comparison","title":"More?","text":"","category":"section"},{"location":"tutorials/model_comparison/","page":"Model comparison","title":"Model comparison","text":"True vs. simulated data\nRT distributions conditional on choice\nCross-validation?","category":"page"},{"location":"apireference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apireference/#Core-types","page":"API Reference","title":"Core types","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"ADDM.Trial\nADDM.aDDM\nADDM.define_model","category":"page"},{"location":"apireference/#ADDM.Trial","page":"API Reference","title":"ADDM.Trial","text":"Trial(choice, RT, valueLeft, valueRight)\n\nArguments\n\nRequired keyword arguments\n\nchoice: either -1 (for left item) or +1 (for right item).\nRT: response time in milliseconds.\nvalueLeft: value of the left item.\nvalueRight: value of the right item.\n\nOptional\n\nfixItem: list of items fixated during the trial in chronological   order; 1 correponds to left, 2 corresponds to right, and any   other value is considered a transition/blank fixation.\nfixTime: list of fixation durations (in milliseconds) in   chronological order.\nfixRDV: list of Float64 corresponding to the RDV values at the end of   each fixation in the trial.\nuninterruptedLastFixTime: Int64 corresponding to the duration, in   milliseconds, that the last fixation in the trial would have if it   had not been interrupted when a decision was made.\nRDV: vector of RDV over time.\n\nExample\n\njulia> t = Trial(choice = 1, RT = 2145, valueLeft = 1, valueRight = 3)\nTrial(1, 2145, 1, 3, #undef, #undef, #undef, #undef, #undef)\n\njulia> t.RT\n2145\n\njulia> t.uninterruptedLastFixTime\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] getproperty(x::Trial, f::Symbol)\n   @ Base ./Base.jl:37\n [2] top-level scope\n   @ REPL[4]:1\n\njulia> t.uninterruptedLastFixTime = 189\n189\n\njulia> t\nTrial(1, 2145, 1, 3, #undef, #undef, #undef, 189, #undef)\n\n\n\n\n\n","category":"type"},{"location":"apireference/#ADDM.aDDM","page":"API Reference","title":"ADDM.aDDM","text":"Constructor for model definitions that will contain model parameter and parameter value   mapping. Not intended to be used alone but as part of define_model\n\nExample\n\njulia> MyModel = ADDM.aDDM()\naDDM(Dict{Symbol, Any}())\n\njulia> MyModel.d = 0.005\n0.005\n\njulia> MyModel.σ = .06\n0.06\n\njulia> MyModel\naDDM(Dict{Symbol, Any}(:σ => 0.06, :d => 0.005))\n\n\n\n\n\n","category":"type"},{"location":"apireference/#ADDM.define_model","page":"API Reference","title":"ADDM.define_model","text":"define_model(d, σ, θ = 1, η = 0, barrier = 1, decay = 0, nonDecisionTime = 0, bias = 0.0)\n\nCreate attentional drift diffusion model with parameters described in    Krajbich et al. (2010).\n\nArguments\n\nRequired parameters\n\nd: Number, parameter of the model which controls the speed of   integration of the signal.\nσ: Number, parameter of the model, standard deviation for the   normal distribution.\n\nOptional parameters\n\nθ: Float64 Traditionally between 0 and 1, parameter of the model which controls   the attentional discounting. Default at 1 makes it a ddm.\nη: Float64 Additive attentional enhancement the attentional discounting.    Default at 0 makes it a ddm.\nbarrier: positive Int64, boundary separation in each direction from 0. Default at 1.\ndecay: constant for linear barrier decay at each time step. Default at 0.\nnonDecisionTime: non-negative Number, the amount of time in   milliseconds during which processes other than evidence accummulation occurs.    Default at 0.\nbias: Number, corresponds to the initial value of the relative decision value   variable. Must be smaller than barrier.\n\nTodo\n\nTests\nChange decay parameter to function instead of scalar\n\nExample\n\njulia julia> MyModel = define_model(d = .006, σ = 0.05) aDDM(Dict{Symbol, Any}(:nonDecisionTime => 0, :σ => 0.05, :d => 0.006, :bias => 0.0, :barrier => 1, :decay => 0, :θ => 1.0, :η => 0.0))`\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Fixation-data","page":"API Reference","title":"Fixation data","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"ADDM.FixationData   \nADDM.process_fixations  \nADDM.convert_to_fixationDist  ","category":"page"},{"location":"apireference/#ADDM.FixationData","page":"API Reference","title":"ADDM.FixationData","text":"FixationData(probFixLeftFirst, latencies, transitions, fixations; \n             fixDistType=\"fixation\")\n\nArguments:\n\nprobFixLeftFirst: Float64 between 0 and 1, empirical probability that   the left item will be fixated first.\nlatencies: Vector corresponding to the empirical distribution of   trial latencies (delay before first fixation) in milliseconds.\ntransitions: Vector corresponding to the empirical distribution   of transitions (delays between item fixations) in milliseconds.\nfixations: Dict whose indexing is defined according to parameter   fixDistType. Each entry is an array corresponding to the   empirical distribution of item fixation durations in   milliseconds.\nfixDistType: String, one of {'simple', 'difficulty', 'fixation'},   determines how the fixation distributions are indexed. If   'simple', fixation distributions are indexed only by type (1st,   2nd, etc). If 'difficulty', they are indexed by type and by trial   difficulty, i.e., the absolute value for the trial's value   difference. If 'fixation', they are indexed by type and by the   value difference between the fixated and unfixated items.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#ADDM.process_fixations","page":"API Reference","title":"ADDM.process_fixations","text":"process_fixations(data::Dict; timeStep::Number = 10, \n                                 maxFixTime::Number = 3000, \n                                 numFixDists::Int64 = 3, fixDistType::String = \"fixation\", \n                                 valueDiffs::Vector{Int64} = collect(-3:1:3), \n                                 subjectIds::Vector{String} = String[])\n\nCreate empirical distributions from the data to be used when generating model simulations.\n\nArguments\n\ndata: a dict, indexed by subjectId, where each entry is a list of   Trial objects. E.g. output of load_data_from_csv\ntimeStep: integer, minimum duration of a fixation to be considered, in   miliseconds.\nmaxFixTime: integer, maximum duration of a fixation to be considered, in   miliseconds.\nnumFixDists: integer, number of fixation types to use in the fixation   distributions. For instance, if numFixDists equals 3, then 3 separate   fixation types will be used, corresponding to the 1st, 2nd and other   (3rd and up) fixations in each trial.\nfixDistType: string, one of {'simple', 'difficulty', 'fixation'}, used to   determine how the fixation distributions should be indexed. If   'simple', then fixation distributions will be indexed only by type   (1st, 2nd, etc). If 'difficulty', they will be indexed by type and by   trial difficulty, i.e., the absolute value for the trial's value   difference. If 'fixation', they will be indexed by type and by the   value difference between the fixated and unfixated items. Note that    this is not the same as the value difference for the trial. \nvalueDiffs: list of integers. If fixDistType is 'difficulty' or   'fixation', valueDiffs is a range correspoding to the item values to   be used when indexing the fixation distributions. So if difficulty   make sure to input absolute value differences if that is the measure   of difficulty of the decision.\nsubjectIds: list of strings corresponding to the subjects whose data   should be used. If not provided, all existing subjects will be used.\n\nReturn\n\nA FixationData object.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#ADDM.convert_to_fixationDist","page":"API Reference","title":"ADDM.convert_to_fixationDist","text":"convert_to_fixationDist(fixationData::FixationData; timeStep::Number = 10)\n\nCreate empirical distributions from the data to be used when generating model simulations.\n\nArguments\n\nfixationData: FixationData type that is the output of process_fixations.\ntimeStep: integer, timeBin size in ms.\n\nReturn\n\nfixationDist: Dictionary indexed by value difference and fixation type. Contains the distributions of fixation durations in each time bin specifiu\ntimeBinMidPoints: Mid points of the time bins, for which the fixation  duration distributions were calculated. Will be the durations sampled in  addm_simulate_trial if using fixationDist instead of fixationData\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Data-simulation","page":"API Reference","title":"Data simulation","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"ADDM.aDDM_simulate_trial\nADDM.DDM_simulate_trial\nADDM.simulate_data","category":"page"},{"location":"apireference/#ADDM.aDDM_simulate_trial","page":"API Reference","title":"ADDM.aDDM_simulate_trial","text":"aDDM_simulate_trial(model::aDDM, fixationData::FixationData, \n                    valueLeft::Number, valueRight::Number; timeStep::Number=10.0, \n                    numFixDists::Int64=3 , fixationDist=nothing, timeBins=nothing, \n                    cutOff::Number=100000)\n\nGenerate a DDM trial given the item values.\n\nArguments\n\nmodel: aDDM object.\nfixationData: FixationData object. Required even when using fixationDist because it specifies latencies and transitions as well.\nvalueLeft: value of the left item.\nvalueRight: value of the right item.\ntimeStep: Number, value in milliseconds to be used for binning   time axis.\nnumFixDists: Int64, number of fixation types to use in the fixation   distributions. For instance, if numFixDists equals 3, then 3   separate fixation types will be used, corresponding to the 1st,   2nd and other (3rd and up) fixations in each trial.\nfixationDist: distribution of fixations which, when provided, will be   used instead of fixationData.fixations. This should be a dict of   dicts of dicts, corresponding to the probability distributions of   fixation durations. Indexed first by fixation type (1st, 2nd, etc),   then by the value difference between the fixated and unfixated    items, then by time bin. Each entry is a number between 0 and 1    corresponding to the probability assigned to the particular time   bin (i.e. given a particular fixation type and value difference,   probabilities for all bins should add up to 1). Can be obtained from   fixationData using convert_to_fixationDist. If using this instead   of fixationData to sample fixations make sure to specify latency and    transition info in fixationData.\ntimeBins: array containing the time bins used in fixationDist. Can be   obtained fromfixationData using convert_to_fixationDist\n\nReturns\n\nAn Trial object resulting from the simulation.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#ADDM.DDM_simulate_trial","page":"API Reference","title":"ADDM.DDM_simulate_trial","text":"DDM_simulate_trial(model::aDDM, valueLeft::Number, valueRight::Number; timeStep::Number = 10.0, \n                   cutOff::Int64 = 20000)\n\nGenerate a DDM trial given the item values.\n\nArguments\n\nmodel: aDDM object.\nvalueLeft: value of the left item.\nvalueRight: value of the right item.\ntimeStep: Number, value in milliseconds to be used for binning the   time axis.\ncutOff: Number, value in milliseconds to be used as a cap if trial   response time is too long.\nReturns\nA Trial object resulting from the simulation.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#ADDM.simulate_data","page":"API Reference","title":"ADDM.simulate_data","text":"simulate_data(model::aDDM, stimuli, simulator_fn, simulator_args = (timeStep = 10.0, cutOff = 20000))\n\nSimulate data using the model for the given stimuli.\n\nArguments\n\nmodel: aDDM object.\nstimuli: Named tuple with valueLeft and valueRight specifying the values of options.\nsimulator_fn: Name of the function that simulates a trial for the given model.\nsimulator_args: Named tuple containing kwargs that should be fed to simulator_fn\n\nReturns\n\nVector of Trial objects containing simulated data.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Likelihood-computation","page":"API Reference","title":"Likelihood computation","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"ADDM.aDDM_get_trial_likelihood\nADDM.DDM_get_trial_likelihood\nADDM.compute_trials_nll","category":"page"},{"location":"apireference/#ADDM.aDDM_get_trial_likelihood","page":"API Reference","title":"ADDM.aDDM_get_trial_likelihood","text":"aDDM_get_trial_likelihood(addm::aDDM, trial::aDDMTrial; timeStep::Number = 10.0, \n                          approxStateStep::Number = 0.1)\n\nCompute the likelihood of the data from a single aDDM trial for these particular aDDM    parameters.\n\nArguments:\n\nmodel: aDDM object.\ntrial: Trial object.\ntimeStep: Number, value in milliseconds to be used for binning the   time axis.\napproxStateStep: Number, to be used for binning the RDV axis.\n\nReturns:\n\nThe likelihood obtained for the given trial and model.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#ADDM.DDM_get_trial_likelihood","page":"API Reference","title":"ADDM.DDM_get_trial_likelihood","text":"DDM_get_trial_likelihood(ddm::aDDM, trial::Trial; timeStep::Number = 10, \n                         approxStateStep::Number = 0.1, \n                         decay::Number = 0)\n\nCompute the likelihood of the data from a single DDM trial for these particular DDM parameters.\n\nArguments\n\nmodel: aDDM object.\ntrial: Trial object.\ntimeStep: Number, value in milliseconds to be used for binning the   time axis.\napproxStateStep: Number, to be used for binning the RDV axis.\n\nReturns\n\nThe likelihood obtained for the given trial and model.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#ADDM.compute_trials_nll","page":"API Reference","title":"ADDM.compute_trials_nll","text":"compute_trials_nll(model::aDDM, data, likelihood_fn, likelihood_args = (timeStep = 10.0, cutOff = 20000))\n\nCompute likelihood of a dataset for a given model.\n\nArguments\n\nmodel: aDDM object. Holds info on the parameter values for the likelihood function.\ndata: Vector of ADDM.Trial objects. \nlikelihood_fn: Name of the function that computes the likelhoods of a trial for the given model.\nlikelihood_args: Named tuple containing kwargs that should be fed to likelihood_fn\nreturn_trial_likelihoods: Boolean to specify whether to return the likelihoods for each trial\n\nReturns\n\nNegative log likelihood of data\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Grid-search","page":"API Reference","title":"Grid search","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"ADDM.grid_search","category":"page"},{"location":"apireference/#ADDM.grid_search","page":"API Reference","title":"ADDM.grid_search","text":"grid_search(data, likelihood_fn, param_grid, return_grid_likelihoods = false; \n            likelihood_args =  (timeStep = 10.0, approxStateStep = 0.1), return_trial_likelihoods = false)\n\nCompute the likelihood of either observed or simulated data for all parameter combinations in param_grid.\n\nArguments\n\nRequired\n\ndata: Data for which the sum of negative log likelihoods will be computed for each trial. Should be a vector of ADDM.Trial objects.\nlikelihood_fn: Name of likelihood function to be used to compute likelihoods.  The toolbox has ADDM.aDDM_get_trial_likelihood and ADDM.aDDM_get_trial_likelihood defined.\nparam_grid: Grid of parameter combinations for which the sum of nll's for the data is  computed.\nfixed_params: Default Dict(:θ=>1.0, :η=>0.0, :barrier=>1, :decay=>0, :nonDecisionTime=>0, :bias=>0.0). Parameters required by the likelihood_fn that are not specified to vary across likelihood  computations.\n\nOptional\n\nreturn_grid_nlls: Default true. If true, will return the sum of nll's for  each parameter combination in the grid search.\nlikelihood_args: Default (timeStep = 10.0, approxStateStep = 0.1). Additional  arguments to be passed onto likelihood_fn. \nreturn_model_posteriors: Default false. If true, will return the posterior probability  for each parameter combination in param_grid.\nmodel_priors: priors for each model probability if not assummed to be uniform. Should be specified as a Dict with values of probabilities mathing the keys for the correct model specified in param_grid.\n\nReturns\n\nbest_part: Dict containing the parameter combination with the lowest nll.\nall_nll_df: DataFrame containing sum of nll's for each parameter combination.\nposteriors: Likelihood for each trial for each parameter combination.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Helpers","page":"API Reference","title":"Helpers","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"ADDM.load_data_from_csv\nADDM.convert_param_symbols","category":"page"},{"location":"apireference/#ADDM.load_data_from_csv","page":"API Reference","title":"ADDM.load_data_from_csv","text":"load_data_from_csv(expdataFileName, fixationsFileName; convertItemValues=nothing)\n\nLoad experimental data from two CSV files: an experimental data file and a fixations file. Format expected for experimental data file: parcode, trial, rt, choice, itemleft, itemright. Format expected for fixations file: parcode, trial, fixitem, fixtime.\n\nArguments\n\nexpdataFileName: String, name of experimental data file.\nfixationsFileName: String, name of fixations file.\nparcode: Subject identifier\ntrial: Trial number\nfix_item: Fixation location. 0 = transition, 1 = left, 2 = right,\n3 = latency.\nfix_time: Fixation duration.\n\nReturn\n\nA dict, indexed by subjectId, where each entry is a list of Trial       objects.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#ADDM.convert_param_symbols","page":"API Reference","title":"ADDM.convert_param_symbols","text":"convert_param_symbols(model)\n\nConvert parameter names that are specified in text into greek/latex symbols. Used by ADDM.grid_search\n\n\n\n\n\n","category":"function"},{"location":"tutorials/custom_model/#Defining-custom-models","page":"Defining custom models","title":"Defining custom models","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"Though the packages comes with the standard attentional DDM that allows for multiplicative and additive discounting of unattended items, users might also conceive of other generative processes (within the sequantial sampling to a bound framework) that give rise to observed choices, response times.  ","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"In this tutorial we lay out the framework for how to incorporate such models within our toolbox to take advantage of Julia's processing speed.  ","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"Broadly, this involves defining three parts: ","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"trial simulator describing how the new parameter changes the data generating process resulting in a choice and response time\nthis is then fed into ADDM.simulate_data along with the model object and stimuli to generate choice and response times.\nmodel object with new parameter\nthis is only a container of key-value pairs of parameter names and values used a convenient wrapper to feed into the simulator and likelihood computer.\ntrial likelihood calculator computing the probability of the observed choice and response time\nthis is then fed into ADDM.grid_search along with the data you want to compute the likelihoods for and the parameter search space.","category":"page"},{"location":"tutorials/custom_model/#Load-package","page":"Defining custom models","title":"Load package","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"using ADDM\nusing CSV\nusing DataFrames\nusing Distributions\nusing LinearAlgebra\nusing StatsPlots","category":"page"},{"location":"tutorials/custom_model/#Define-simulator","page":"Defining custom models","title":"Define simulator","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"The built-in model has a decay parameter for a linear decay of the barrier. Let's build a model with an exponential decay of the barrier such that the barrier at each timestep is defined as barrier(t) = exp(-λt).","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"Based on the built-in trial simulators as defined here the trial simulator would look like the following:","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"function my_trial_simulator(;model::ADDM.aDDM, fixationData::ADDM.FixationData, \n                        valueLeft::Number, valueRight::Number, \n                        timeStep::Number=10.0, numFixDists::Int64=3, cutOff::Number=100000)\n    \n    fixUnfixValueDiffs = Dict(1 => valueLeft - valueRight, 2 => valueRight - valueLeft)\n    \n    fixItem = Number[]\n    fixTime = Number[]\n    fixRDV = Number[]\n\n    RDV = model.bias\n    trialTime = 0\n    choice = 0\n    tRDV = Number[RDV]\n    RT = 0\n    uninterruptedLastFixTime = 0\n    ndtTimeSteps = Int64(model.nonDecisionTime ÷ timeStep)\n\n    # The values of the barriers can change over time.\n    # In this case we include an exponential decay\n    # Due to the shape of the exponential decay function the starting point for the decay is exp(0) = 1\n    barrierUp = exp.(-model.λ .* (0:cutOff-1))\n    barrierDown = -exp.(-model.λ .* (0:cutOff-1))\n    \n    # Sample and iterate over the latency for this trial.\n    latency = rand(fixationData.latencies)\n    remainingNDT = model.nonDecisionTime - latency\n\n    # This will not change anything (i.e. move the RDV) if there is no latency data in the fixations\n    for t in 1:Int64(latency ÷ timeStep)\n        # Sample the change in RDV from the distribution.\n        RDV += rand(Normal(0, model.σ))\n        push!(tRDV, RDV)\n\n        # If the RDV hit one of the barriers, the trial is over.\n        # No barrier decay before decision-related accummulation\n        if abs(RDV) >= model.barrier\n            choice = RDV >= 0 ? -1 : 1\n            push!(fixRDV, RDV)\n            push!(fixItem, 0)\n            push!(fixTime, t * timeStep)\n            trialTime += t * timeStep\n            RT = trialTime\n            uninterruptedLastFixTime = latency\n            trial = Trial(choice = choice, RT = RT, valueLeft = valueLeft, valueRight = valueRight)\n            trial.fixItem = fixItem \n            trial.fixTime = fixTime \n            trial.fixRDV = fixRDV\n            trial.uninterruptedLastFixTime = uninterruptedLastFixTime\n            trial.RDV = tRDV\n            return trial\n        end\n    end\n\n    # Add latency to this trial's data\n    push!(fixRDV, RDV)\n    push!(fixItem, 0)\n    push!(fixTime, latency - (latency % timeStep))\n    trialTime += latency - (latency % timeStep)\n\n    fixNumber = 1\n    prevFixItem = -1\n    currFixLocation = 0\n    decisionReached = false\n\n    # Begin decision related accummulation\n    cumTimeStep = 0\n    while true\n        if currFixLocation == 0\n            # This is an item fixation; sample its location.\n            if prevFixItem == -1\n                # Sample the first item fixation for this trial.\n                currFixLocation = rand(Bernoulli(1 - fixationData.probFixLeftFirst)) + 1\n            elseif prevFixItem in [1, 2]\n                currFixLocation = abs(3 - prevFixItem)\n            end\n            prevFixItem = currFixLocation\n\n            # Sample the duration of this item fixation.\n            valueDiff = fixUnfixValueDiffs[currFixLocation]\n            #[1] is here to make sure it's not sampling from 1-element Vector but from the array inside it\n            currFixTime = rand(fixationData.fixations[fixNumber][valueDiff][1]) \n            \n\n            if fixNumber < numFixDists\n                fixNumber += 1\n            end\n\n        else\n            # This is a transition.\n             currFixLocation = 0\n            # Sample the duration of this transition. The fixation data used below does not have transition information so ignoring this.\n            # currFixTime = rand(fixationData.transitions)\n            currFixTime = 0\n        end\n\n        # Iterate over the remaining non-decision time remaining after the latency\n        # This can span more than first fixation depending on the first fixation duration\n        # That's why it's not conditioned over the fixation number\n        if remainingNDT > 0\n            for t in 1:Int64(remainingNDT ÷ timeStep)\n                # Sample the change in RDV from the distribution.\n                RDV += rand(Normal(0, model.σ))\n                push!(tRDV, RDV)\n\n                # If the RDV hit one of the barriers, the trial is over.\n                # No barrier decay before decision-related accummulation\n                if abs(RDV) >= model.barrier\n                    choice = RDV >= 0 ? -1 : 1\n                    push!(fixRDV, RDV)\n                    push!(fixItem, currFixLocation)\n                    push!(fixTime, t * timeStep)\n                    trialTime += t * timeStep\n                    RT = trialTime\n                    uninterruptedLastFixTime = currFixTime\n                    decisionReached = true\n                    break\n                end\n            end\n        end\n\n        # Break out of the while loop if decision reached during NDT\n        # The break above only breaks from the NDT for loop\n        if decisionReached\n            break\n        end\n\n        remainingFixTime = max(0, currFixTime - max(0, remainingNDT))\n        remainingNDT -= currFixTime\n\n        # Iterate over the duration of the current fixation.\n        # Does not move RDV if there is no fixation time left due to NDT\n        for t in 1:Int64(remainingFixTime ÷ timeStep)\n            # We use a distribution to model changes in RDV\n            # stochastically. The mean of the distribution (the change\n            # most likely to occur) is calculated from the model\n            # parameters and from the values of the two items.\n            if currFixLocation == 0\n                μ = 0\n            elseif currFixLocation == 1\n                μ = model.d * ( (valueLeft + model.η) - (model.θ * valueRight))\n            elseif currFixLocation == 2\n                μ = model.d * ((model.θ * valueLeft) - (valueRight + model.η))\n            end\n\n            # Sample the change in RDV from the distribution.\n            RDV += rand(Normal(μ, model.σ))\n            push!(tRDV, RDV)\n\n            # Increment cumulative timestep to look up the correct barrier value in case there has been a decay\n            # Decay in this case only happens during decision-related accummulation (not before)\n            # Don't want to use t here because this is reset for each fixation throughout a trial but the barrier is not\n            cumTimeStep += 1\n\n            # If the RDV hit one of the barriers, the trial is over.\n            # Decision related accummulation here so barrier might have decayed\n            if abs(RDV) >= barrierUp[cumTimeStep]\n                choice = RDV >= 0 ? -1 : 1\n                push!(fixRDV, RDV)\n                push!(fixItem, currFixLocation)\n                push!(fixTime, t * timeStep)\n                trialTime += t * timeStep\n                RT = trialTime\n                uninterruptedLastFixTime = currFixTime\n                decisionReached = true\n                break\n            end\n        end\n\n        # Break out of the while loop if decision reached during NDT\n        # The break above only breaks from the curFixTime for loop\n        if decisionReached\n            break\n        end\n\n        # Add fixation to this trial's data.\n        push!(fixRDV, RDV)\n        push!(fixItem, currFixLocation)\n        push!(fixTime, currFixTime - (currFixTime % timeStep))\n        trialTime += currFixTime - (currFixTime % timeStep)\n\n    end\n\n    trial = ADDM.Trial(choice = choice, RT = RT, valueLeft = valueLeft, valueRight = valueRight)\n    trial.fixItem = fixItem \n    trial.fixTime = fixTime \n    trial.fixRDV = fixRDV\n    trial.uninterruptedLastFixTime = uninterruptedLastFixTime\n    trial.RDV = tRDV\n    return trial\nend","category":"page"},{"location":"tutorials/custom_model/#Define-model-container","page":"Defining custom models","title":"Define model container","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"Now create a model object of class aDDM to store the parameters of our model. There are two ways of doing this. First, we could use the ADDM.define_model function. That would like:","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"my_model = ADDM.define_model(d = 0.007, σ = 0.03, θ = .6, barrier = 1, nonDecisionTime = 100, bias = 0.0)","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"my_model.λ = .05","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"The ADDM.define_model function is limited to the standard parameter names. So the new parameter λ is added to the model after its creation. Alternatively, we can create an empty model object and add our parameters individually.","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"my_model = ADDM.aDDM()\nmy_model.d = 0.007\nmy_model.σ = 0.03\nmy_model.θ = .6\nmy_model.η = 0\nmy_model.barrier = 1\nmy_model.nonDecisionTime = 100\nmy_model.bias = 0.0\nmy_model.λ = .05","category":"page"},{"location":"tutorials/custom_model/#Simulate-data","page":"Defining custom models","title":"Simulate data","text":"","category":"section"},{"location":"tutorials/custom_model/#Define-stimuli-and-fixation-distribution","page":"Defining custom models","title":"Define stimuli and fixation distribution","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"We will use sample empirical data from Krajbich et al. (2010) to create sample stimuli and fixation distributions. Importantly, we will not be using the empirical choices and response times but instead simulate our own data given the generative process we defined in our custom model and the parameter values we specify for it (i.e. in this notebook we do not fit this custom model to the empirical data from Krajbich et al.).","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"fn = \"../../../data/Krajbich2010_stims.csv\"\ntmp = DataFrame(CSV.File(fn, delim=\",\"))\nmy_stims = (valueLeft = tmp.item_left, valueRight = tmp.item_right)","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"data = ADDM.load_data_from_csv(\"../../../data/Krajbich2010_behavior.csv\", \"../../../data/Krajbich2010_fixations.csv\")\nvDiffs = sort(unique(my_stims.valueLeft - my_stims.valueRight))\nmy_fixations = ADDM.process_fixations(data, fixDistType=\"fixation\", valueDiffs = vDiffs)\n\n# There no second fixation durations for vDiff == 7 so we'll use the third fixation info for second too.\nmy_fixations.fixations[2][7] = my_fixations.fixations[3][7]","category":"page"},{"location":"tutorials/custom_model/#Simulate-choice-and-response-times","page":"Defining custom models","title":"Simulate choice and response times","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"There are 97b rows in the stims. We'll add more trials to help recover true parameters.","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"length(my_stims.valueRight)","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"my_args = (timeStep = 10.0, cutOff = 20000, fixationData = my_fixations);","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"Simuluate one set of data with the stimuli.","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"my_sim_data = ADDM.simulate_data(my_model, my_stims, my_trial_simulator, my_args);","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"Add two more sets of data","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"for i in 1:2\n  this_sim_data = ADDM.simulate_data(my_model, my_stims, my_trial_simulator, my_args)\n  append!(my_sim_data, this_sim_data)\n  i += 1\nend;","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"length(my_sim_data)","category":"page"},{"location":"tutorials/custom_model/#Define-likelihood-function","page":"Defining custom models","title":"Define likelihood function","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"function my_likelihood_fn(;model::ADDM.aDDM, trial::ADDM.Trial, timeStep::Number = 10.0, \n                                   approxStateStep::Number = 0.1)\n    \n    # Iterate over the fixations and discount the non-decision time.\n    if model.nonDecisionTime > 0\n        correctedFixItem = Number[]\n        correctedFixTime = Number[]\n        remainingNDT = model.nonDecisionTime\n        for (fItem, fTime) in zip(trial.fixItem, trial.fixTime) # iterate through each fixation in the trial\n            if remainingNDT > 0\n                push!(correctedFixItem, 0)\n                push!(correctedFixTime, min(remainingNDT, fTime)) # if the fTime is smaller push that otherwise push ndt\n                push!(correctedFixItem, fItem)\n                push!(correctedFixTime, max(fTime - remainingNDT, 0))\n                remainingNDT = remainingNDT - fTime\n            else\n                push!(correctedFixItem, fItem)\n                push!(correctedFixTime, fTime)\n            end\n        end\n    else\n        correctedFixItem = trial.fixItem\n        correctedFixTime = trial.fixTime\n    end\n    \n    # Iterate over the fixations and get the number of time steps for this trial.\n    numTimeSteps = 0\n    \n    for fTime in correctedFixTime\n        numTimeSteps += Int64(fTime ÷ timeStep)\n    end\n    \n    if numTimeSteps < 1\n        throw(RuntimeError(\"Trial response time is smaller than time step.\"))\n    end\n    numTimeSteps += 1\n    \n    # The values of the barriers can change over time.\n    barrierUp = exp.(-model.λ .* (0:numTimeSteps-1))\n    barrierDown = -exp.(-model.λ .* (0:numTimeSteps-1))\n    \n    # Obtain correct state step.\n    halfNumStateBins = ceil(model.barrier / approxStateStep)\n    stateStep = model.barrier / (halfNumStateBins + 0.5)\n    \n    # The vertical axis is divided into states.\n    states = range(-1*(model.barrier) + stateStep / 2, 1*(model.barrier) - stateStep/2, step=stateStep)\n    \n    # Find the state corresponding to the bias parameter.\n    biasState = argmin(abs.(states .- model.bias))\n    \n    # Initial probability for all states is zero, except the bias state,\n    # for which the initial probability is one.\n    prStates = zeros(length(states), numTimeSteps)\n    prStates[biasState,1] = 1\n    \n    # The probability of crossing each barrier over the time of the trial.\n    probUpCrossing = zeros(numTimeSteps)\n    probDownCrossing = zeros(numTimeSteps)\n    \n    time = 1\n    \n    # Dictionary of μ values from fItem.\n    μDict = Dict{Number, Number}()\n    for fItem in 0:2\n        if fItem == 1\n            μ = model.d * ((trial.valueLeft + model.η) - (model.θ * trial.valueRight))\n        elseif fItem == 2\n            μ = model.d * ((model.θ * trial.valueLeft) - (trial.valueRight + model.η))\n        else\n            μ = 0\n        end\n        \n        μDict[fItem] = μ\n    end \n    \n    changeMatrix = states .- reshape(states, 1, :)\n    changeUp = (barrierUp .- reshape(states, 1, :))'\n    changeDown = (barrierDown .- reshape(states, 1, :) )'\n    \n    pdfDict = Dict{Number, Any}()\n    cdfUpDict = Dict{Number, Any}()\n    cdfDownDict = Dict{Number, Any}() \n    \n    for fItem in 0:2\n        normpdf = similar(changeMatrix)\n        cdfUp = similar(changeUp[:, time])\n        cdfDown = similar(changeDown[:, time])\n        \n        @. normpdf = pdf(Normal(μDict[fItem], model.σ), changeMatrix)\n        @. cdfUp = cdf(Normal(μDict[fItem], model.σ), changeUp[:, time])\n        @. cdfDown = cdf(Normal(μDict[fItem], model.σ), changeDown[:, time])\n        pdfDict[fItem] = normpdf\n        cdfUpDict[fItem] = cdfUp\n        cdfDownDict[fItem] = cdfDown\n    end\n    \n    # Iterate over all fixations in this trial.\n    for (fItem, fTime) in zip(correctedFixItem, correctedFixTime)\n        # We use a normal distribution to model changes in RDV\n        # stochastically. The mean of the distribution (the change most\n        # likely to occur) is calculated from the model parameters and from\n        # the item values.\n        μ = μDict[fItem]\n        normpdf = pdfDict[fItem]\n        cdfUp = cdfUpDict[fItem]\n        cdfDown = cdfDownDict[fItem]\n        \n        # Iterate over the time interval of this fixation.\n        for t in 1:Int64(fTime ÷ timeStep)\n            # Update the probability of the states that remain inside the \n            # barriers. The probability of being in state B is the sum, \n            # over all states A, of the probability of being in A at the \n            # previous timestep times the probability of changing from A to\n            # B. We multiply the probability by the stateStep to ensure\n            # that the area under the curves for the probability \n            # distributions probUpCrossing and probDownCrossing add up to 1.\n            prStatesNew = stateStep * (normpdf * prStates[:,time])\n            prStatesNew[(states .>= barrierUp[time]) .| (states .<= barrierDown[time])] .= 0\n            \n            # Calculate the probabilities of crossing the up barrier and\n            # the down barrier. This is given by the sum, over all states\n            # A, of the proability of being in A at the previous timestep\n            # times the probability of crossing the barrier if A is the\n            # previous state.\n            tempUpCross = dot(prStates[:,time], 1 .- cdfUp)\n            tempDownCross = dot(prStates[:,time], cdfDown)\n            \n            # Renormalize to cope with numerical approximations.\n            sumIn = sum(prStates[:,time])\n            sumCurrent = sum(prStatesNew) + tempUpCross + tempDownCross\n            prStatesNew = prStatesNew * sumIn / sumCurrent\n            tempUpCross = tempUpCross * sumIn / sumCurrent\n            tempDownCross = tempDownCross * sumIn / sumCurrent\n\n            # Update the probabilities of each state and the probabilities of\n            # crossing each barrier at this timestep\n            prStates[:,time+1] = prStatesNew\n            probUpCrossing[time+1] = tempUpCross\n            probDownCrossing[time+1] = tempDownCross\n            \n            time += 1\n        end\n    end\n    \n    # Compute the likelihood contribution of this trial based on the final\n    # choice.\n    likelihood = 0\n    if trial.choice == -1 # Choice was left.\n        if probUpCrossing[end] > 0\n            likelihood = probUpCrossing[end]\n        end\n    elseif trial.choice == 1 # Choice was right.\n        if probDownCrossing[end] > 0 \n            likelihood = probDownCrossing[end]\n        end\n    end\n    \n    return likelihood\nend","category":"page"},{"location":"tutorials/custom_model/#Recover-parameters-for-simulated-data","page":"Defining custom models","title":"Recover parameters for simulated data","text":"","category":"section"},{"location":"tutorials/custom_model/#Define-search-grid","page":"Defining custom models","title":"Define search grid","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"fn = \"../../../data/custom_model_grid.csv\";\ntmp = DataFrame(CSV.File(fn, delim=\",\"));\nparam_grid = Dict(pairs(NamedTuple.(eachrow(tmp))))","category":"page"},{"location":"tutorials/custom_model/#Run-grid-search-on-simulated-data","page":"Defining custom models","title":"Run grid search on simulated data","text":"","category":"section"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"fixed_params = Dict(:η=>0.0, :barrier=>1, :decay=>0, :nonDecisionTime=>100, :bias=>0.0)\n\nmy_likelihood_args = (timeStep = 10.0, approxStateStep = 0.01)\n\nbest_pars, nll_df, model_posteriors = ADDM.grid_search(my_sim_data, my_likelihood_fn, param_grid, \n    fixed_params, \n    likelihood_args=my_likelihood_args, \n    return_model_posteriors = true);","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"The true parameters are d = 0.007, σ = 0.03, θ = .6, λ = .05. Even with smaller state space step size the correct decay is not recovered. Instead, the fast response times are attributed to faster drift rates and larger sigmas.","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"sort!(nll_df, [:nll])\n\nshow(nll_df, allrows = true)","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"The posteriors have no uncertainty either.","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"marginal_posteriors = ADDM.marginal_posteriors(param_grid, model_posteriors, true)\n\nADDM.margpostplot(marginal_posteriors)\n\nsavefig(\"plot2.png\"); nothing # hide","category":"page"},{"location":"tutorials/custom_model/","page":"Defining custom models","title":"Defining custom models","text":"(Image: plot)","category":"page"},{"location":"tutorials/getting_started/#Getting-started-with-ADDM.jl","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"","category":"section"},{"location":"tutorials/getting_started/#Load-package","page":"Getting started with ADDM.jl","title":"Load package","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"using ADDM","category":"page"},{"location":"tutorials/getting_started/#Parameter-recovery-on-simulated-data","page":"Getting started with ADDM.jl","title":"Parameter recovery on simulated data","text":"","category":"section"},{"location":"tutorials/getting_started/#Define-model","page":"Getting started with ADDM.jl","title":"Define model","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"MyModel = ADDM.define_model(d = 0.007, σ = 0.03, θ = .6, barrier = 1, \n                decay = 0, nonDecisionTime = 100, bias = 0.0)","category":"page"},{"location":"tutorials/getting_started/#Define-stimuli","page":"Getting started with ADDM.jl","title":"Define stimuli","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"This should be of type NamedTuple with required field names (case sensitive): valueLeft and valueRight ","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Option 1: Read in from CSV  ","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"note: Note\nNote that the CSV and DataFrames modules must be loaded beforehand. These are dependencies for the ADDM module but the precompiled module gives access to these dependencies only in the scope of ADDM. In other words, ADDM.load_data_from_csv that requires both of these packages would still work but the code below would not without importing these modules to the current interactive scope.    ","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"using CSV\nusing DataFrames\n\n# fn = \"./data/stims.csv\"\nfn = \"../../../data/stims.csv\"\ntmp = DataFrame(CSV.File(fn, delim=\",\"))\nMyStims = (valueLeft = tmp.valueLeft, valueRight = tmp.valueRight)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Option 2: Create random stimuli","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"note: Note\nIf you're going to create random stimuli you should make sure to have value differences that correspond to what you plan to fit in for fixation data.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Random.seed!(38535)\nMyStims = (valueLeft = randn(1000), valueRight = randn(1000))","category":"page"},{"location":"tutorials/getting_started/#Define-fixationData","page":"Getting started with ADDM.jl","title":"Define fixationData","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Fixation information that will be fed in to the model for simulations should be of type FixationData. This type organizes empirical fixations to distributions conditional on fixation type (first, second etc.) and value difference.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"This organizes both the behavioral and the fixation data as a dictionary of Trial objects indexed by subject. Here, we are reading in empirical data that comes with the package but we will not be making use of the observed choices and response times. The empirical data is only used to extract value difference information to index the fixation data correctly. The choices and response times will be simulated below based on the parameters we specified above.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Note also that the ADDM.load_data_from_csv() will expect columns parcode,trial, rt, choice, item_left, item_right and convert item_left anditem_right to valueLeft and valueRight. ","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"data = ADDM.load_data_from_csv(\"../../../data/expdata.csv\", \"../../../data/fixations.csv\")","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Extract value difference information from the dataset to use in processing the fixations","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"vDiffs = sort(unique([x.valueLeft - x.valueRight for x in data[\"1\"]]))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"When simulating an aDDM we need to input fixations. But instead of using the fixation data from any given subject we summarize the empricial data from all subjects as distributions from which the model samples from depending on the value difference and the fixation type (1st, 2nd etc.).","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"MyFixationData = ADDM.process_fixations(data, fixDistType=\"fixation\", valueDiffs = vDiffs)","category":"page"},{"location":"tutorials/getting_started/#Simulate-data","page":"Getting started with ADDM.jl","title":"Simulate data","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"First we define additional arguments for aDDM trial simulator (e.g. fixation data, time step for simulations). Note these need to be specified as a NamedTuple, and must have at least two elements. Otherwise it tries to apply iterate to the single element which would likely end with a  MethodError. In this example I specify timeStep and cutoff in addition to the  only required argument without a default fixationData to avoid this.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"MyArgs = (timeStep = 10.0, cutOff = 20000, fixationData = MyFixationData)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Note that these are positional arguments for code efficiency","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"SimData = ADDM.simulate_data(MyModel, MyStims, ADDM.aDDM_simulate_trial, MyArgs)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Data can also be simulated from probability distributions of fixation data.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"MyFixationDist, MyTimeBins = ADDM.convert_to_fixationDist(MyFixationData)\n\nMyBlankFixationData = ADDM.FixationData(MyFixationData.probFixLeftFirst, MyFixationData.latencies, MyFixationData.transitions, Dict())\n\nMyArgs = (fixationData = MyBlankFixationData, fixationDist = MyFixationDist, timeBins = MyTimeBins)\n\nSimData = ADDM.simulate_data(MyModel, MyStims, ADDM.aDDM_simulate_trial, MyArgs)","category":"page"},{"location":"tutorials/getting_started/#Recover-parameters-using-a-grid-search","page":"Getting started with ADDM.jl","title":"Recover parameters using a grid search","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"The ADDM.grid_search function computes","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"fn = \"../../../data/addm_grid.csv\"\ntmp = DataFrame(CSV.File(fn, delim=\",\"))\nparam_grid = Dict(pairs(NamedTuple.(eachrow(tmp))))\n\nbest_pars, all_nll_df = ADDM.grid_search(SimData, ADDM.aDDM_get_trial_likelihood, param_grid, Dict(:η=>0.0, :barrier=>1, :decay=>0, :nonDecisionTime=>100, :bias=>0.0))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Examine the sum of negative log likelihoods for each parameter combination.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"sort!(all_nll_df, [:nll])","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"Save data frame containing the negative log likelihood info for all parameter combinations you searched for. ","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"note: Note\nMake sure that you have mounted a local directory to your container if you're working through this tutorial in a docker container. The output path below is the one specified in the installation instructions. You should change it if you want to save your output elsewhere.output_path = '/home/jovyan/work/all_nll_df.csv'\nCSV.write(output_path, all_nll_df)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"You might have noticed that the grid search did not identify the true parameters (d = 0.007, σ = 0.03, θ = .6) as the ones with the highest likelihood. This highlights the importance of choosing good stepsizes for the temporal and spatial discretization.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"The default stepsizes are defined as timeStep = 10.0, approxStateStep = 0.1. Let's reduce the spatial step size and see if we can recover the corect parameter combination.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started with ADDM.jl","title":"Getting started with ADDM.jl","text":"my_likelihood_args = (timeStep = 10.0, approxStateStep = 0.01)\n\nbest_pars, all_nll_df = ADDM.grid_search(SimData, ADDM.aDDM_get_trial_likelihood, param_grid, Dict(:η=>0.0, :barrier=>1, :decay=>0, :nonDecisionTime=>100, :bias=>0.0), likelihood_args=my_likelihood_args)\n\nsort!(all_nll_df, [:nll])","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Documentation)  (Image: CI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to ADDM.jl, a package for  joint modeling of response times, eyetracking data and choice behavior using evidence accummulations models with time-varying drift rates. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#Currently","page":"Home","title":"Currently","text":"","category":"section"},{"location":"#Docker","page":"Home","title":"Docker","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This option is for those who don't want to deal with installing any dependencies. See below for instructions on how to install via Github","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install and start Docker Desktop\nFrom the command line interface you have for your sistem\nRun the command below to start a Julia REPL. Note that this will mount your current working directory onto a path in the container so you can save your outputs locally if needed (more on this below)\ndocker run -it --rm \\\n-v $(pwd):/home/jovyan/work \\\nrnlcaltech/addm-toolbox:addm.jl\nOr start a notebook in a container based on the image using the command.   \ndocker run -it --rm \\\n-v $(pwd):/home/jovyan/work \\\n-p 8888:8888 rnlcaltech/addm-toolbox:addm.jl jupyter-lab\ndocker run -it --rm: this is the main command to start a container from an image. The two flags are -it to interact with the container interactively and --rm so docker cleans up after we're done with the container\n-v $(pwd):/home/jovyan/work: this mounts your local directory, wherever you're running this command from as captured by $(pwd) on to the file system in the docker image at path /home/jovyan/work. You can change either side of : to mount another directory from your system or to another path in the container. This part is critical if you want to be able to write out and save any output from your analyses that run in the container. Otherwise they will disappear when you kill the container (because we are starting the container with the --rm flag).\n-p 8888:8888: this connects a local port to the jupyter-lab port in the container. If you have any other jupyter-lab notebooks running locally that are listening on the 8888 port you should change this to e.g. -p 8989:8888 so it does not ask you for a token when you go to the URL this command lists in its output.\nrnlcaltech/addm-toolbox:addm.jl jupyter-lab: this specifies the container name with the tag and the entry point (the beginning command) you want to run in the container. The output will look similar to when you start a jupyter notebook locally. Go to the URL listed in the output in a browser to start a notebook and begin exploring the toolbox as described in Getting started with ADDM.jl\nTo kill the container hit cmd + c","category":"page"},{"location":"#Github","page":"Home","title":"Github","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have Julia and Git installed and want a local copy of the toolbox on your machine you can follow the intructions below. Note that, this will require you to install all Julia dependencies (in it's own environmet).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Clone the Github repo","category":"page"},{"location":"","page":"Home","title":"Home","text":"git clone https://github.com/aDDM-Toolbox/ADDM.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"Navigate to the ADDM.jl directory","category":"page"},{"location":"","page":"Home","title":"Home","text":"cd ADDM.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Set up the Julia environment (might take a few minutes)","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project -e 'import Pkg; Pkg.instantiate()'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Start up a Julia REPL using the project's environment","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project","category":"page"},{"location":"#Once-ADDM.jl-is-on-the-Julia-Registry","page":"Home","title":"Once ADDM.jl is on the Julia Registry","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install ADDM.jl from the Julia Registry if you want a local copy of it. Alternatively you can use the Docker images as described above.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"ADDM\")","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ADDM.jl is licensed under the GNU General Public License v3.0.","category":"page"},{"location":"#Resources-for-getting-started","page":"Home","title":"Resources for getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are a few ways to get started with ADDM.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Become familiar with the modeling framework described in Krajbich et al. (2010)  \nBecome familiar with algorithm used for parameter estimation Tavares et al. (2017)  \nRead the introductory tutorial","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you need help, please open a GitHub issue.","category":"page"},{"location":"#Citing-ADDM.jl","page":"Home","title":"Citing ADDM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ADDM.jl, we ask that you please cite the following:","category":"page"},{"location":"tutorials/empirical_data/#Parameter-estimation-on-empirical-data","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"","category":"section"},{"location":"tutorials/empirical_data/#Load-packages","page":"Parameter estimation on empirical data","title":"Load packages","text":"","category":"section"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"using ADDM\nusing CSV\nusing DataFrames\nusing StatsPlots","category":"page"},{"location":"tutorials/empirical_data/#Read-in-data","page":"Parameter estimation on empirical data","title":"Read in data","text":"","category":"section"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"Data in this tutorial are from 10 subjects in Kraijbich et al (2010). We will use the built-in data loading function ADDM.load_data_from_csv that expects a behavioral file with columns parcode, trial, rt, choice, item_left, item_right and fixations file with columns parcode, trial, fix_item, fix_time","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"If your data is not organized in this way you could either preprocess it so it does or you can read in the data however you want and reshape it with Julia to ensure it is organized as a dictionary of Trial objects indexed by subject/parcode. A Trial looks like","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"ADDM.Trial(1, 1474.0, -5, 5, Number[3, 0, 1, 0, 2, 0], Number[270.0, 42.0, 246.0, 62.0, 558.0, 296.0], #undef, #undef, #undef)","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"where the first element is choice (-1 for left, +1 for right), second element is response time in ms, third is value of left option, fourth is value of right option. Fixation data is specified in the fourth and fifth elements as fixation location (1 for left, 2 for right) and fixation duration (in ms) respectively.  ","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"krajbich_data = ADDM.load_data_from_csv(\"../../../data/Krajbich2010_behavior.csv\", \"../../../data/Krajbich2010_fixations.csv\")","category":"page"},{"location":"tutorials/empirical_data/#Grid-search","page":"Parameter estimation on empirical data","title":"Grid search","text":"","category":"section"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"Using a grid of 64 parameter combinations with d in {0.0001, 0.00015, 0.0002, 0.00025}, μ in {80, 100, 120, 140}, θ in {0.3, 0.5, 0.7, 0.9}  and σ = d*μ   ","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"fn = \"../../../data/Krajbich_grid.csv\"\ntmp = DataFrame(CSV.File(fn, delim=\",\"))\nparam_grid = Dict(pairs(NamedTuple.(eachrow(tmp))))\n\nall_nll_df = DataFrame()\nbest_pars = Dict()\n\nfor k in keys(krajbich_data)\n  cur_subj_data = krajbich_data[k]\n  \n  subj_best_pars, subj_nll_df = ADDM.grid_search(cur_subj_data, ADDM.aDDM_get_trial_likelihood, param_grid, Dict(:η=>0.0, :barrier=>1, :decay=>0, :nonDecisionTime=>0, :bias=>0.0))\n\n  best_pars[k] = subj_best_pars\n\n  subj_nll_df[!, \"parcode\"] .= k\n  append!(all_nll_df, subj_nll_df)\n  \nend","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"To view best parameter estimates for each subject","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"best_pars","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"Plot variability in the negative log likelihoods for each parameter combination for each subject","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"wide_nll_df = unstack(all_nll_df, :parcode, :nll)\nselect!(wide_nll_df, Not([:d, :sigma, :theta]))\ncolnames = names(wide_nll_df)\ncolnames = string.(\"subj-\", colnames)\nN = length(colnames)\n\n@df wide_nll_df histogram(cols(1:N); layout=grid(2,5), legend=false, title=permutedims(colnames), frame=:box, titlefontsize=11, c=:blues, bins = 20, size=(1800,1000), xrotation = 45)\n\nsavefig(\"plot1.png\"); nothing # hide","category":"page"},{"location":"tutorials/empirical_data/","page":"Parameter estimation on empirical data","title":"Parameter estimation on empirical data","text":"(Image: plot)","category":"page"}]
}
